<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kalendarz Astronomiczny 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #020510;
            color: #fff;
            overflow-x: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .header {
            text-align: center;
            padding: 20px;
            pointer-events: auto;
            background: linear-gradient(180deg, rgba(2, 5, 16, 0.95) 0%, rgba(2, 5, 16, 0) 100%);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.1em;
            color: #b0b8d4;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(2, 5, 16, 0.65);
            backdrop-filter: blur(10px);
            padding: 0;
            border-radius: 20px 20px 0 0;
            max-width: 100%;
            width: 100%;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: none;
            transition: transform 0.3s ease;
            z-index: 100;
        }

        .controls.collapsed {
            transform: translateY(calc(100% - 80px));
        }

        .controls-header {
            padding: 15px 25px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            user-select: none;
        }

        .controls-header:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .toggle-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }

        .controls.collapsed .toggle-icon {
            transform: rotate(180deg);
        }

        .controls-content {
            padding: 25px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .date-control {
            margin-bottom: 20px;
        }

        .date-control label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #e0e6ff;
        }

        .date-control input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 1em;
        }

        .info-panel {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            padding: 30px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            margin-top: 20px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ffd700;
        }

        .info-label {
            font-size: 0.85em;
            color: #b0b8d4;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #fff;
        }

        .season-info {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .season-name {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .season-progress {
            margin-top: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #ffd700);
            border-radius: 12px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .camera-controls {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(2, 5, 16, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .camera-controls h3 {
            font-size: 0.9em;
            margin-bottom: 10px;
            color: #b0b8d4;
        }

        .camera-controls p {
            font-size: 0.8em;
            color: #888;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5em;
            }
            
            .subtitle {
                font-size: 0.9em;
            }

            .controls.collapsed {
                transform: translateY(calc(100% - 70px));
            }

            .controls-header {
                padding: 12px 20px;
            }

            .controls-content {
                padding: 20px;
                max-height: 70vh;
            }

            .camera-controls {
                display: none;
            }

            .info-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .info-item {
                padding: 10px;
            }

            .info-label {
                font-size: 0.8em;
            }

            .info-value {
                font-size: 1em;
            }

            .season-name {
                font-size: 1.3em;
            }

            .header {
                padding: 10px;
            }

            .date-control {
                margin-bottom: 15px;
            }

            .date-control input {
                padding: 10px;
                font-size: 0.9em;
            }

            .info-panel {
                padding: 15px;
            }

            .season-info {
                padding: 12px;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.3em;
            }
            
            .controls.collapsed {
                transform: translateY(calc(100% - 60px));
            }

            .controls-header {
                padding: 10px 15px;
            }
            
            .controls-content {
                padding: 15px;
            }
            
            .info-item {
                padding: 8px;
            }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #ffd700;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="ui-overlay">
        <div class="header">
            <h1>üåç Kalendarz Astronomiczny 3D</h1>
            <p class="subtitle">Ziemia na swojej orbicie wok√≥≈Ç S≈Ço≈Ñca</p>
        </div>

        <div class="camera-controls">
            <h3 id="cameraControlsTitle">Sterowanie kamerƒÖ:</h3>
            <p id="cameraControlsText">üñ±Ô∏è Lewy przycisk: Obracanie<br>
            üñ±Ô∏è Prawy przycisk: Przesuwanie<br>
            üîÑ Scroll: Przybli≈ºanie/Oddalanie<br><br>
            üì± Na telefonie:<br>
            üëÜ Jeden palec: Obracanie<br>
            ü§è Dwa palce: Zoom i przesuwanie</p>
        </div>

        <div class="controls collapsed">
            <div class="controls-header" id="controlsToggle">
                <div class="season-name" id="seasonNameHeader">-</div>
                <div class="toggle-icon">‚ñ≤</div>
            </div>
            
            <div class="controls-content">
                <div class="info-panel">
                    <div class="season-info">
                        <div class="season-name" id="seasonName">-</div>
                        <div class="info-label" id="seasonInfo">-</div>
                        <div class="season-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="seasonProgress">0%</div>
                            </div>
                        </div>
                    </div>

                    <div class="info-grid">
                        <div class="info-item">
                            <div class="info-label">Data</div>
                            <div class="info-value" id="currentDate">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Dzie≈Ñ w roku</div>
                            <div class="info-value" id="dayOfYear">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Pozycja na orbicie</div>
                            <div class="info-value" id="orbitPosition">-</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading" id="loading">≈Åadowanie...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script>
        // System wielojƒôzyczno≈õci
        const translations = {
            pl: {
                title: 'üåç Kalendarz Astronomiczny 3D',
                subtitle: 'Ziemia na swojej orbicie wok√≥≈Ç S≈Ço≈Ñca',
                cameraControls: 'Sterowanie kamerƒÖ:',
                leftClick: 'Lewy przycisk: Obracanie',
                rightClick: 'Prawy przycisk: Przesuwanie',
                scroll: 'Scroll: Przybli≈ºanie/Oddalanie',
                selectDate: 'Wybierz datƒô:',
                date: 'Data',
                dayOfYear: 'Dzie≈Ñ w roku',
                orbitPosition: 'Pozycja na orbicie',
                spring: 'üå∏ Wiosna',
                summer: '‚òÄÔ∏è Lato',
                autumn: 'üçÇ Jesie≈Ñ',
                winter: '‚ùÑÔ∏è Zima',
                daysRemaining: 'Pozosta≈Ço {days} dni',
                seasonProgress: '({current}/{total} dni)',
                loading: '≈Åadowanie...'
            },
            en: {
                title: 'üåç 3D Astronomical Calendar',
                subtitle: 'Earth on its orbit around the Sun',
                cameraControls: 'Camera Controls:',
                leftClick: 'Left button: Rotate',
                rightClick: 'Right button: Pan',
                scroll: 'Scroll: Zoom In/Out',
                selectDate: 'Select date:',
                date: 'Date',
                dayOfYear: 'Day of year',
                orbitPosition: 'Orbit position',
                spring: 'üå∏ Spring',
                summer: '‚òÄÔ∏è Summer',
                autumn: 'üçÇ Autumn',
                winter: '‚ùÑÔ∏è Winter',
                daysRemaining: '{days} days remaining',
                seasonProgress: '({current}/{total} days)',
                loading: 'Loading...'
            },
            de: {
                title: 'üåç 3D Astronomischer Kalender',
                subtitle: 'Die Erde auf ihrer Umlaufbahn um die Sonne',
                cameraControls: 'Kamerasteuerung:',
                leftClick: 'Linke Taste: Drehen',
                rightClick: 'Rechte Taste: Verschieben',
                scroll: 'Scrollen: Zoomen',
                selectDate: 'Datum w√§hlen:',
                date: 'Datum',
                dayOfYear: 'Tag des Jahres',
                orbitPosition: 'Bahnposition',
                spring: 'üå∏ Fr√ºhling',
                summer: '‚òÄÔ∏è Sommer',
                autumn: 'üçÇ Herbst',
                winter: '‚ùÑÔ∏è Winter',
                daysRemaining: '{days} Tage verbleibend',
                seasonProgress: '({current}/{total} Tage)',
                loading: 'Wird geladen...'
            },
            es: {
                title: 'üåç Calendario Astron√≥mico 3D',
                subtitle: 'La Tierra en su √≥rbita alrededor del Sol',
                cameraControls: 'Controles de c√°mara:',
                leftClick: 'Bot√≥n izquierdo: Rotar',
                rightClick: 'Bot√≥n derecho: Desplazar',
                scroll: 'Scroll: Acercar/Alejar',
                selectDate: 'Seleccionar fecha:',
                date: 'Fecha',
                dayOfYear: 'D√≠a del a√±o',
                orbitPosition: 'Posici√≥n orbital',
                spring: 'üå∏ Primavera',
                summer: '‚òÄÔ∏è Verano',
                autumn: 'üçÇ Oto√±o',
                winter: '‚ùÑÔ∏è Invierno',
                daysRemaining: '{days} d√≠as restantes',
                seasonProgress: '({current}/{total} d√≠as)',
                loading: 'Cargando...'
            },
            fr: {
                title: 'üåç Calendrier Astronomique 3D',
                subtitle: 'La Terre sur son orbite autour du Soleil',
                cameraControls: 'Contr√¥les de la cam√©ra:',
                leftClick: 'Bouton gauche: Rotation',
                rightClick: 'Bouton droit: D√©placement',
                scroll: 'Scroll: Zoom',
                selectDate: 'S√©lectionner la date:',
                date: 'Date',
                dayOfYear: 'Jour de l\'ann√©e',
                orbitPosition: 'Position orbitale',
                spring: 'üå∏ Printemps',
                summer: '‚òÄÔ∏è √ât√©',
                autumn: 'üçÇ Automne',
                winter: '‚ùÑÔ∏è Hiver',
                daysRemaining: '{days} jours restants',
                seasonProgress: '({current}/{total} jours)',
                loading: 'Chargement...'
            },
            it: {
                title: 'üåç Calendario Astronomico 3D',
                subtitle: 'La Terra nella sua orbita intorno al Sole',
                cameraControls: 'Controlli fotocamera:',
                leftClick: 'Pulsante sinistro: Ruota',
                rightClick: 'Pulsante destro: Sposta',
                scroll: 'Scroll: Zoom',
                selectDate: 'Seleziona data:',
                date: 'Data',
                dayOfYear: 'Giorno dell\'anno',
                orbitPosition: 'Posizione orbitale',
                spring: 'üå∏ Primavera',
                summer: '‚òÄÔ∏è Estate',
                autumn: 'üçÇ Autunno',
                winter: '‚ùÑÔ∏è Inverno',
                daysRemaining: '{days} giorni rimanenti',
                seasonProgress: '({current}/{total} giorni)',
                loading: 'Caricamento...'
            },
            ru: {
                title: 'üåç 3D –ê—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–π –ö–∞–ª–µ–Ω–¥–∞—Ä—å',
                subtitle: '–ó–µ–º–ª—è –Ω–∞ –æ—Ä–±–∏—Ç–µ –≤–æ–∫—Ä—É–≥ –°–æ–ª–Ω—Ü–∞',
                cameraControls: '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π:',
                leftClick: '–õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞: –í—Ä–∞—â–µ–Ω–∏–µ',
                rightClick: '–ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ',
                scroll: '–ü—Ä–æ–∫—Ä—É—Ç–∫–∞: –ú–∞—Å—à—Ç–∞–±',
                selectDate: '–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:',
                date: '–î–∞—Ç–∞',
                dayOfYear: '–î–µ–Ω—å –≥–æ–¥–∞',
                orbitPosition: '–ü–æ–∑–∏—Ü–∏—è –Ω–∞ –æ—Ä–±–∏—Ç–µ',
                spring: 'üå∏ –í–µ—Å–Ω–∞',
                summer: '‚òÄÔ∏è –õ–µ—Ç–æ',
                autumn: 'üçÇ –û—Å–µ–Ω—å',
                winter: '‚ùÑÔ∏è –ó–∏–º–∞',
                daysRemaining: '–û—Å—Ç–∞–ª–æ—Å—å {days} –¥–Ω–µ–π',
                seasonProgress: '({current}/{total} –¥–Ω–µ–π)',
                loading: '–ó–∞–≥—Ä—É–∑–∫–∞...'
            },
            ja: {
                title: 'üåç 3DÂ§©Êñá„Ç´„É¨„É≥„ÉÄ„Éº',
                subtitle: 'Â§™ÈôΩ„ÅÆÂë®„Çä„ÇíÂõû„ÇãÂú∞ÁêÉ',
                cameraControls: '„Ç´„É°„É©Êìç‰Ωú:',
                leftClick: 'Â∑¶„Éú„Çø„É≥: ÂõûËª¢',
                rightClick: 'Âè≥„Éú„Çø„É≥: ÁßªÂãï',
                scroll: '„Çπ„ÇØ„É≠„Éº„É´: „Ç∫„Éº„É†',
                selectDate: 'Êó•‰ªò„ÇíÈÅ∏Êäû:',
                date: 'Êó•‰ªò',
                dayOfYear: 'Âπ¥Èñì„ÅÆÊó•',
                orbitPosition: 'ËªåÈÅì‰ΩçÁΩÆ',
                spring: 'üå∏ Êò•',
                summer: '‚òÄÔ∏è Â§è',
                autumn: 'üçÇ Áßã',
                winter: '‚ùÑÔ∏è ÂÜ¨',
                daysRemaining: 'ÊÆã„Çä{days}Êó•',
                seasonProgress: '({current}/{total}Êó•)',
                loading: 'Ë™≠„ÅøËæº„Åø‰∏≠...'
            },
            zh: {
                title: 'üåç 3DÂ§©ÊñáÊó•ÂéÜ',
                subtitle: 'Âú∞ÁêÉÁªïÂ§™Èò≥ËøêË°åÁöÑËΩ®ÈÅì',
                cameraControls: 'Áõ∏Êú∫ÊéßÂà∂:',
                leftClick: 'Â∑¶ÈîÆ: ÊóãËΩ¨',
                rightClick: 'Âè≥ÈîÆ: Âπ≥Áßª',
                scroll: 'ÊªöËΩÆ: Áº©Êîæ',
                selectDate: 'ÈÄâÊã©Êó•Êúü:',
                date: 'Êó•Êúü',
                dayOfYear: 'Âπ¥Â∫¶Êó•',
                orbitPosition: 'ËΩ®ÈÅì‰ΩçÁΩÆ',
                spring: 'üå∏ Êò•Â§©',
                summer: '‚òÄÔ∏è Â§èÂ§©',
                autumn: 'üçÇ ÁßãÂ§©',
                winter: '‚ùÑÔ∏è ÂÜ¨Â§©',
                daysRemaining: 'Ââ©‰Ωô{days}Â§©',
                seasonProgress: '({current}/{total}Â§©)',
                loading: 'Âä†ËΩΩ‰∏≠...'
            }
        };

        // Wykryj jƒôzyk przeglƒÖdarki
        function detectLanguage() {
            const browserLang = navigator.language || navigator.userLanguage;
            const langCode = browserLang.split('-')[0].toLowerCase();
            
            // Je≈õli mamy t≈Çumaczenie dla tego jƒôzyka, u≈ºyj go, w przeciwnym razie u≈ºyj angielskiego
            return translations[langCode] ? langCode : 'en';
        }

        const currentLang = detectLanguage();
        const t = translations[currentLang];

        // Funkcja do t≈Çumaczenia z parametrami
        function translate(key, params = {}) {
            let text = t[key] || translations.en[key] || key;
            Object.keys(params).forEach(param => {
                text = text.replace(`{${param}}`, params[param]);
            });
            return text;
        }

        // Zaktualizuj teksty na stronie
        function updateUITexts() {
            document.querySelector('h1').textContent = t.title;
            document.querySelector('.subtitle').textContent = t.subtitle;
            document.querySelector('.camera-controls h3').textContent = t.cameraControls;
            
            const controlTexts = document.querySelectorAll('.camera-controls p')[0];
            controlTexts.innerHTML = `üñ±Ô∏è ${t.leftClick}<br>üñ±Ô∏è ${t.rightClick}<br>üîÑ ${t.scroll}`;
            
            // Aktualizuj etykiety w info-grid (w prawid≈Çowej kolejno≈õci)
            const infoLabels = document.querySelectorAll('.info-grid .info-label');
            if (infoLabels.length >= 3) {
                infoLabels[0].textContent = t.date;
                infoLabels[1].textContent = t.dayOfYear;
                infoLabels[2].textContent = t.orbitPosition;
            }
            
            document.getElementById('loading').textContent = t.loading;
            document.title = t.title;
        }

        // Zmienne globalne
        let scene, camera, renderer, controls, composer;
        let earth, sun, orbit, earthGroup;
        let currentDate = new Date();

        // Ustawienia
        const ORBIT_RADIUS = 15; // P√≥≈Ço≈õ wielka (a)
        const ORBIT_ECCENTRICITY = 0.1; // Zwiƒôkszony mimo≈õr√≥d dla lepszej widoczno≈õci (prawdziwy to 0.0167)
        const PERIHELION_RADIUS = ORBIT_RADIUS * (1 - ORBIT_ECCENTRICITY); // Stycze≈Ñ - najbli≈ºej S≈Ço≈Ñca
        const APHELION_RADIUS = ORBIT_RADIUS * (1 + ORBIT_ECCENTRICITY); // Lipiec - najdalej od S≈Ço≈Ñca
        const EARTH_RADIUS = 0.8;
        const SUN_RADIUS = 2;

        // Pory roku - nazwy bƒôdƒÖ brane z t≈Çumacze≈Ñ
        const seasons = {
            spring: { name: t.spring, start: { month: 3, day: 20 } },
            summer: { name: t.summer, start: { month: 6, day: 21 } },
            autumn: { name: t.autumn, start: { month: 9, day: 23 } },
            winter: { name: t.winter, start: { month: 12, day: 21 } }
        };

        // Inicjalizacja sceny
        function init() {
            // Scena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020510);

            // Kamera
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(25, 20, 25);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post-processing z efektem bloom dla miƒôkkiej po≈õwiaty
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,  // strength - si≈Ça efektu bloom
                0.8,  // radius - promie≈Ñ rozmycia
                0.3   // threshold - pr√≥g jasno≈õci (ni≈ºszy = wiƒôcej obiekt√≥w ≈õwieci)
            );
            composer.addPass(bloomPass);

            // Proste kontrolki orbity (bez OrbitControls)
            setupCameraControls();

            // O≈õwietlenie
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 2, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Gwiazdy
            createStars();

            // S≈Ço≈Ñce
            createSun();

            // Orbita z gradientem
            createOrbit();

            // Ziemia
            createEarth();

            // Obs≈Çuga zmiany rozmiaru okna
            window.addEventListener('resize', onWindowResize);

            // Ukryj loading
            document.getElementById('loading').style.display = 'none';

            // Start animacji
            animate();
        }

        function setupCameraControls() {
            let isDragging = false;
            let isPanning = false;
            let previousMousePosition = { x: 0, y: 0 };
            let cameraRotation = { theta: Math.PI / 4, phi: Math.PI / 3.5 };
            let cameraDistance = 43;
            let cameraTarget = new THREE.Vector3(0, 0, 0);

            // Limity przesuwania
            const PAN_LIMIT = 20;

            // Obs≈Çuga myszy - desktop
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) isDragging = true;
                if (e.button === 2) isPanning = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    cameraRotation.theta -= deltaX * 0.01;
                    cameraRotation.phi -= deltaY * 0.01;
                    cameraRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraRotation.phi));

                    updateCameraPosition();
                }

                if (isPanning) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    const viewDirection = new THREE.Vector3();
                    camera.getWorldDirection(viewDirection);
                    
                    const right = new THREE.Vector3();
                    right.crossVectors(viewDirection, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    const up = new THREE.Vector3();
                    up.crossVectors(right, viewDirection).normalize();

                    const panSpeed = 0.03;
                    const newTarget = cameraTarget.clone();
                    newTarget.add(right.multiplyScalar(-deltaX * panSpeed));
                    newTarget.add(up.multiplyScalar(deltaY * panSpeed));

                    newTarget.x = Math.max(-PAN_LIMIT, Math.min(PAN_LIMIT, newTarget.x));
                    newTarget.y = Math.max(-PAN_LIMIT, Math.min(PAN_LIMIT, newTarget.y));
                    newTarget.z = Math.max(-PAN_LIMIT, Math.min(PAN_LIMIT, newTarget.z));

                    cameraTarget.copy(newTarget);
                    updateCameraPosition();
                }

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            // Obs≈Çuga dotyku - mobile
            let touchStartDistance = 0;
            let initialCameraDistance = cameraDistance;
            let touches = [];

            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touches = Array.from(e.touches);

                if (touches.length === 1) {
                    // Jeden palec - obracanie
                    isDragging = true;
                    previousMousePosition = { x: touches[0].clientX, y: touches[0].clientY };
                } else if (touches.length === 2) {
                    // Dwa palce - zoom i przesuwanie
                    isDragging = false;
                    isPanning = true;
                    
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                    initialCameraDistance = cameraDistance;
                    
                    previousMousePosition = {
                        x: (touches[0].clientX + touches[1].clientX) / 2,
                        y: (touches[0].clientY + touches[1].clientY) / 2
                    };
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                touches = Array.from(e.touches);

                if (touches.length === 1 && isDragging) {
                    // Obracanie jednym palcem
                    const deltaX = touches[0].clientX - previousMousePosition.x;
                    const deltaY = touches[0].clientY - previousMousePosition.y;

                    cameraRotation.theta -= deltaX * 0.01;
                    cameraRotation.phi -= deltaY * 0.01;
                    cameraRotation.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraRotation.phi));

                    updateCameraPosition();
                    previousMousePosition = { x: touches[0].clientX, y: touches[0].clientY };
                    
                } else if (touches.length === 2) {
                    // Pinch zoom
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const scale = touchStartDistance / distance;
                    cameraDistance = initialCameraDistance * scale;
                    cameraDistance = Math.max(10, Math.min(100, cameraDistance));
                    
                    // Przesuwanie dwoma palcami
                    const currentMidpoint = {
                        x: (touches[0].clientX + touches[1].clientX) / 2,
                        y: (touches[0].clientY + touches[1].clientY) / 2
                    };
                    
                    const deltaX = currentMidpoint.x - previousMousePosition.x;
                    const deltaY = currentMidpoint.y - previousMousePosition.y;

                    const viewDirection = new THREE.Vector3();
                    camera.getWorldDirection(viewDirection);
                    
                    const right = new THREE.Vector3();
                    right.crossVectors(viewDirection, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    const up = new THREE.Vector3();
                    up.crossVectors(right, viewDirection).normalize();

                    const panSpeed = 0.03;
                    const newTarget = cameraTarget.clone();
                    newTarget.add(right.multiplyScalar(-deltaX * panSpeed));
                    newTarget.add(up.multiplyScalar(deltaY * panSpeed));

                    newTarget.x = Math.max(-PAN_LIMIT, Math.min(PAN_LIMIT, newTarget.x));
                    newTarget.y = Math.max(-PAN_LIMIT, Math.min(PAN_LIMIT, newTarget.y));
                    newTarget.z = Math.max(-PAN_LIMIT, Math.min(PAN_LIMIT, newTarget.z));

                    cameraTarget.copy(newTarget);
                    previousMousePosition = currentMidpoint;
                    
                    updateCameraPosition();
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                touches = Array.from(e.touches);
                
                if (touches.length === 0) {
                    isDragging = false;
                    isPanning = false;
                } else if (touches.length === 1) {
                    isDragging = true;
                    isPanning = false;
                    previousMousePosition = { x: touches[0].clientX, y: touches[0].clientY };
                }
            }, { passive: false });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.05;
                cameraDistance = Math.max(10, Math.min(100, cameraDistance));
                updateCameraPosition();
            });

            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            function updateCameraPosition() {
                camera.position.x = cameraTarget.x + cameraDistance * Math.sin(cameraRotation.phi) * Math.cos(cameraRotation.theta);
                camera.position.y = cameraTarget.y + cameraDistance * Math.cos(cameraRotation.phi);
                camera.position.z = cameraTarget.z + cameraDistance * Math.sin(cameraRotation.phi) * Math.sin(cameraRotation.theta);
                camera.lookAt(cameraTarget);
            }

            updateCameraPosition();
        }

        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];

            for (let i = 0; i < 2000; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                starPositions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            
            // Tworzenie okrƒÖg≈Çej tekstury dla gwiazd
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // Rysuj gradient radialny (okrƒÖg≈Ça gwiazda)
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.8,
                map: texture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function createSun() {
            const sunGeometry = new THREE.SphereGeometry(SUN_RADIUS, 32, 32);
            const sunMaterial = new THREE.MeshStandardMaterial({
                color: 0xffeb3b,
                emissive: 0xffeb3b,
                emissiveIntensity: 2
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            // Jedna warstwa po≈õwiaty - efekt bloom zrobi resztƒô
            const glowGeometry = new THREE.SphereGeometry(SUN_RADIUS * 1.3, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffa726,
                transparent: true,
                opacity: 0.5,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            sun.add(glow);
        }

        function createOrbit() {
            const segments = 360;
            const positions = [];
            const colors = [];

            // Parametry elipsy
            const a = ORBIT_RADIUS; // P√≥≈Ço≈õ wielka
            const b = a * Math.sqrt(1 - ORBIT_ECCENTRICITY * ORBIT_ECCENTRICITY); // P√≥≈Ço≈õ ma≈Ça
            const c = a * ORBIT_ECCENTRICITY; // Przesuniƒôcie ogniska

            // Kolory dla p√≥r roku - zaczynamy od 1 stycznia (zima)
            const seasonColors = [
                { pos: 0.0, color: new THREE.Color(0x6bcbff) },
                { pos: 0.11, color: new THREE.Color(0x4ecdc4) },
                { pos: 0.22, color: new THREE.Color(0x56ab2f) },
                { pos: 0.33, color: new THREE.Color(0xa8e063) },
                { pos: 0.47, color: new THREE.Color(0xffd93d) },
                { pos: 0.58, color: new THREE.Color(0xff9068) },
                { pos: 0.73, color: new THREE.Color(0xff6b6b) },
                { pos: 0.83, color: new THREE.Color(0xff9068) },
                { pos: 0.97, color: new THREE.Color(0xffd93d) },
                { pos: 1.0, color: new THREE.Color(0x6bcbff) }
            ];

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;
                
                // Pozycja na elipsie
                const xOrbit = a * Math.cos(angle);
                const yOrbit = b * Math.sin(angle);
                
                // Przesuniƒôcie - S≈Ço≈Ñce w ognisku
                const x = xOrbit - c;
                const z = yOrbit;
                
                positions.push(x, 0, z);

                // Interpolacja koloru
                const progress = i / segments;
                let color = new THREE.Color();
                
                for (let j = 0; j < seasonColors.length - 1; j++) {
                    if (progress >= seasonColors[j].pos && progress <= seasonColors[j + 1].pos) {
                        const localT = (progress - seasonColors[j].pos) / 
                                      (seasonColors[j + 1].pos - seasonColors[j].pos);
                        color.copy(seasonColors[j].color).lerp(seasonColors[j + 1].color, localT);
                        break;
                    }
                }

                colors.push(color.r, color.g, color.b);
            }

            const orbitGeometry = new THREE.BufferGeometry();
            orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            orbitGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const orbitMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: 5
            });

            orbit = new THREE.Line(orbitGeometry, orbitMaterial);
            scene.add(orbit);

            // Tworzymy eliptycznƒÖ ≈õcie≈ºkƒô dla TubeGeometry
            const tubeSegments = 360;
            const tubeRadius = 0.08;
            
            const points = [];
            for (let i = 0; i <= tubeSegments; i++) {
                const angle = (i / tubeSegments) * Math.PI * 2 - Math.PI / 2;
                const xOrbit = a * Math.cos(angle);
                const yOrbit = b * Math.sin(angle);
                const x = xOrbit - c;
                const z = yOrbit;
                points.push(new THREE.Vector3(x, 0, z));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            curve.closed = true;
            
            const tubeGeometry = new THREE.TubeGeometry(curve, tubeSegments, tubeRadius, 8, true);
            
            // Koloruj tube geometry
            const tubeColors = [];
            const tubePositions = tubeGeometry.attributes.position;
            
            for (let i = 0; i < tubePositions.count; i++) {
                const x = tubePositions.getX(i);
                const z = tubePositions.getZ(i);
                
                // Oblicz kƒÖt z offsetem dla elipsy
                const xShifted = x + c;
                let angle = Math.atan2(z, xShifted) + Math.PI / 2;
                if (angle < 0) angle += Math.PI * 2;
                const progress = angle / (Math.PI * 2);
                
                let color = new THREE.Color();
                for (let j = 0; j < seasonColors.length - 1; j++) {
                    if (progress >= seasonColors[j].pos && progress <= seasonColors[j + 1].pos) {
                        const localT = (progress - seasonColors[j].pos) / 
                                      (seasonColors[j + 1].pos - seasonColors[j].pos);
                        color.copy(seasonColors[j].color).lerp(seasonColors[j + 1].color, localT);
                        break;
                    }
                }
                
                tubeColors.push(color.r, color.g, color.b);
            }
            
            tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(tubeColors, 3));
            
            const tubeMaterial = new THREE.MeshBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.9
            });
            
            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(tubeMesh);
        }

        function createEarth() {
            earthGroup = new THREE.Group();

            // Geometria i tekstura Ziemi
            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 32, 32);
            const earthMaterial = new THREE.MeshPhongMaterial({
                color: 0x2196f3,
                emissive: 0x112244,
                specular: 0x333333,
                shininess: 25
            });

            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            
            // Nachylenie osi Ziemi (23.5 stopnia)
            earth.rotation.z = (23.5 * Math.PI) / 180;

            earthGroup.add(earth);

            // Atmosfera
            const atmosphereGeometry = new THREE.SphereGeometry(EARTH_RADIUS * 1.1, 32, 32);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x6fb3ff,
                transparent: true,
                opacity: 0.2
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            earthGroup.add(atmosphere);

            scene.add(earthGroup);
            updateEarthPosition(currentDate);
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 1);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay) + 1;
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
        }

        function updateEarthPosition(date) {
            const dayOfYear = getDayOfYear(date);
            const year = date.getFullYear();
            const daysInYear = isLeapYear(year) ? 366 : 365;
            
            // Anomalia ≈õrednia - kƒÖt dla r√≥wnomiernego ruchu
            const meanAnomaly = (dayOfYear / daysInYear) * Math.PI * 2 - Math.PI / 2;
            
            // Uproszczona anomalia ekscentryczna (dla ma≈Çych e mo≈ºna u≈ºyƒá przybli≈ºenia)
            // E = M + e*sin(M) (iteracja Keplera uproszczona)
            let E = meanAnomaly;
            for (let i = 0; i < 3; i++) {
                E = meanAnomaly + ORBIT_ECCENTRICITY * Math.sin(E);
            }
            
            // Pozycja na orbicie eliptycznej
            const a = ORBIT_RADIUS; // P√≥≈Ço≈õ wielka
            const b = a * Math.sqrt(1 - ORBIT_ECCENTRICITY * ORBIT_ECCENTRICITY); // P√≥≈Ço≈õ ma≈Ça
            
            // Wsp√≥≈Çrzƒôdne w uk≈Çadzie elipsy
            const xOrbit = a * Math.cos(E);
            const yOrbit = b * Math.sin(E);
            
            // Przesuniƒôcie ≈õrodka elipsy - S≈Ço≈Ñce jest w ognisku, nie w ≈õrodku
            const c = a * ORBIT_ECCENTRICITY; // Odleg≈Ço≈õƒá od ≈õrodka do ogniska
            
            const x = xOrbit - c;
            const z = yOrbit;
            
            earthGroup.position.set(x, 0, z);
        }

        function getSeasonInfo(date) {
            const year = date.getFullYear();
            
            const springStart = new Date(year, 2, 20);
            const summerStart = new Date(year, 5, 21);
            const autumnStart = new Date(year, 8, 23);
            const winterStart = new Date(year, 11, 21);
            const nextSpringStart = new Date(year + 1, 2, 20);

            let currentSeason, seasonStart, seasonEnd, seasonName;

            if (date >= springStart && date < summerStart) {
                seasonStart = springStart;
                seasonEnd = summerStart;
                seasonName = seasons.spring.name;
            } else if (date >= summerStart && date < autumnStart) {
                seasonStart = summerStart;
                seasonEnd = autumnStart;
                seasonName = seasons.summer.name;
            } else if (date >= autumnStart && date < winterStart) {
                seasonStart = autumnStart;
                seasonEnd = winterStart;
                seasonName = seasons.autumn.name;
            } else {
                if (date >= winterStart) {
                    seasonStart = winterStart;
                    seasonEnd = nextSpringStart;
                } else {
                    seasonStart = new Date(year - 1, 11, 21);
                    seasonEnd = springStart;
                }
                seasonName = seasons.winter.name;
            }

            const seasonLength = Math.floor((seasonEnd - seasonStart) / (1000 * 60 * 60 * 24));
            const daysPassed = Math.floor((date - seasonStart) / (1000 * 60 * 60 * 24));
            const daysRemaining = seasonLength - daysPassed;
            const progress = (daysPassed / seasonLength) * 100;

            return {
                name: seasonName,
                daysRemaining,
                progress,
                seasonLength,
                daysPassed
            };
        }

        function updateInfo(date) {
            const dayOfYear = getDayOfYear(date);
            const seasonInfo = getSeasonInfo(date);
            const year = date.getFullYear();
            const daysInYear = isLeapYear(year) ? 366 : 365;
            const orbitPercent = ((dayOfYear / daysInYear) * 100).toFixed(1);

            // Formatowanie daty w zale≈ºno≈õci od jƒôzyka - pe≈Çny format z rokiem
            const dateOptions = { day: 'numeric', month: 'long', year: 'numeric' };
            document.getElementById('currentDate').textContent = date.toLocaleDateString(currentLang, dateOptions);
            
            document.getElementById('dayOfYear').textContent = `${dayOfYear}/${daysInYear}`;
            document.getElementById('orbitPosition').textContent = `${orbitPercent}%`;
            
            document.getElementById('seasonName').textContent = seasonInfo.name;
            
            // U≈ºyj t≈Çumacze≈Ñ dla informacji o sezonie
            const seasonInfoText = translate('daysRemaining', { days: seasonInfo.daysRemaining }) + ' ' +
                                   translate('seasonProgress', { current: seasonInfo.daysPassed, total: seasonInfo.seasonLength });
            document.getElementById('seasonInfo').textContent = seasonInfoText;
            
            const progressBar = document.getElementById('seasonProgress');
            progressBar.style.width = `${seasonInfo.progress}%`;
            progressBar.textContent = `${Math.round(seasonInfo.progress)}%`;
            
            // Aktualizuj nag≈Ç√≥wek (dla zwiniƒôtego UI)
            updateHeader(seasonInfo);
        }

        // Funkcja aktualizujƒÖca nag≈Ç√≥wek (dla zwiniƒôtego UI)
        function updateHeader(seasonInfo) {
            const seasonNameHeader = document.getElementById('seasonNameHeader');
            if (seasonNameHeader) {
                seasonNameHeader.textContent = seasonInfo.name;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotacja Ziemi wok√≥≈Ç w≈Çasnej osi
            earth.rotation.y += 0.005;

            // Rotacja s≈Ço≈Ñca
            sun.rotation.y += 0.002;

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Obs≈Çuga wyboru daty
        const dateInput = document.getElementById('dateInput');
        
        // Obs≈Çuga przycisku rozwijania/zwijania UI
        const controlsToggle = document.getElementById('controlsToggle');
        const controlsPanel = document.querySelector('.controls');
        
        controlsToggle.addEventListener('click', () => {
            controlsPanel.classList.toggle('collapsed');
        });

        // Inicjalizacja
        updateUITexts(); // Zaktualizuj teksty interfejsu
        init();
        updateInfo(currentDate);
    </script>
</body>
</html> 
